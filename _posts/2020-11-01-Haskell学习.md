---
title: Haskell 学习
date: 2020-11-01
layout: post
mathjax: true
category:
- lang
---
#### 1. foldr, foldl 右结合与左结合

````haskell
echoes = foldr (\ x xs -> (replicate x x) ++ xs) [] -- replicate 2 3 => [3 3] 2个3
take 10 (echoes [1..]) -- [1,2,2,3,3,3,4,4,4,4]

echoes = foldl (\ xs x -> xs ++ (replicate x x)) []
take 10 (echoes [1..]) -- not terminating
````

#### 2. $\lambda$ 表达式

一般写法是 `\x1 -> \x2 -> x3 ->...xn -> f(x1, x2, x3, ... xn)`

也是本源的柯里化的写法，可以简写成`\x1 x2 x3 ... xn -> f(x1 x2 x3 ... xn)`

举个例子:

````haskell
Prelude> let add = \x -> \y -> x + y
Prelude> add 1 2
3
Prelude> let add' = \x y -> x + y
Prelude> add' 1 2
3
````

#### 3. 纯函数和惰性求值降低开销

作为真正纯函数式的语言，不同于实际上广泛地使用有副作用的数据结构的某Lisp方言来，说得就是你CommonLisp，

Haskell使用纯函数式的方法进行化简：

3.1 阿尔法化简 ($\alpha$-conversion)

通过变量名重命名来做等价变换:

$\lambda$x -> $\lambda$y -> x + y $\equiv$ $\lambda$a -> $\lambda$y -> a + y 

当然前提不能有命名冲突

3.2 贝塔化简 ($\beta$-reduction)

就是用用实际的函数体替换掉参数

3.3 伊塔化简 ($\eta$-reduction)

冗余简化:

$\lambda$x -> $f$(x) $\equiv$ $f$

需要注意提供必要的完整类型信息，否则为了性能优化而默认单一同态限制(Monomorphism-Restriction) 会错误地分析函数

#### 4. 使用不动点(Fixed Point)对递归本身进行抽象

本身的概念是满足 $f(x) = x$ 的 $x$

fix函数的基本概念可以做如下理解：

`fix f = f (fix f)`

比如牛顿法开方：

````haskell
-- 迭代次数 -> 根值 -> 结果
-- Normal Bad Version
sqrtNB 0 x = x
sqrtNB n x = (sqrtNB(n - 1)x + x / sqrtNB(n - 1)x) / 2

-- 性能很差
> sqrtNB 20 5
2.23606797749979
(1.81 secs, 914,438,408 bytes)
````

使用不动点为：

````haskell
sqrtFix n x = fix (\f n t ->
    if n <= 0
        then t
        else f  (n - 1)
                ((t + x/t) / 2))
    n x

> sqrtFix 20 5
2.23606797749979
(0.01 secs, 93,688 bytes)
````

实际的实现里fix：

````haskell
fix f = let x = f x in x  -- let in 用来限制作用域, in x <=> return x
````

#### 5. Zipper 拉锁提供中间值

````haskell
data Zipper a = Zipper [a] a [a] deriving Show
````

#### 6. 函子(Functor)

````haskell
fmap :: Functor f => (a -> b) -> f a -> f b  -- Data.Function
````

中缀表达式的版本是 `(<$>)`

看着有些奇怪，其实就是类似stream操作，关键参数是 `f` 和 `a -> b` 的函数（构造器）。

````haskell
((* 2) <$> (+ 1) <$> (^ 3)) 2

> 18

(fmap (fmap (* 2) (+ 1)) (^ 3)) 2

> 18
````

等价于 `((2^3) + 1) * 2` 

````
“但除此之外还有更严格的定义：
函子在数学上要符合以下的定律：fmap id = id
如果，使用id函数进行映射，那么与id函数本身是一样的。
fmap (f . g) = fmap f . fmap g
第二条定律则说明 `fmap` 函数在复合函数运算符上是服从分配律的。
值得注意的是，实现了Functor的 `fmap` 函数，但不满足Functor定律则该类型不是Functor。”
    
-- 摘自《Haskell函数式编程入门》
````

#### 6.1 Applicative Functor (讲得不透不全，需要重写)

需要同时实现 pure 、(<*>)

````haskell
class (Functor f) => Applicative f where  
    pure :: a -> f a  
    (<*>) :: f (a -> b) -> f a -> f b  
````

**Java的某个近似的针对构造器“[a]“的应用函子如下：**

````java
Stream.of(
    (IntUnaryOperator) p -> p + 1,
    (IntUnaryOperator) p -> p * 2
)
	.map(f -> Stream.of(1, 2, 3).map(f::applyAsInt))
	.flatMap(Function.identity())
	.collect(Collectors.toList())
    
> [2, 3, 4, 2, 4, 6]
````

**Haskell用应用函元(或者叫做函子)**

````haskell
[(+1), (*2)] <*> [1..3]
````

Haskell的应用函元普遍地适用于构造器，上面的例子是构造器：“[a]”

它等价于：

````haskell
[f x | f <- [(+1), (*2)], x <- [1..3]]
````

因为这就是[]对Applicative的实现

````haskell
-- base-4.15.0.0
-- See Note: [List comprehensions and inlining]
-- | @since 2.01
instance Applicative [] where
    {-# INLINE pure #-}
    pure x    = [x]
    {-# INLINE (<*>) #-}
    fs <*> xs = [f x | f <- fs, x <- xs]  -- 定义在这里
    {-# INLINE liftA2 #-}
    liftA2 f xs ys = [f x y | x <- xs, y <- ys]
    {-# INLINE (*>) #-}
    xs *> ys  = [y | _ <- xs, y <- ys]
````

下面例子针对构造器Maybe

````haskell
instance Applicative Maybe where  
    pure = Just  
    Nothing <*> _ = Nothing  
    (Just f) <*> something = fmap f something

(fmap (+) (Just 3)) <*> Just 2
> Just 5

-- 等价于:
-- fmap (+) (Just 3) <*> Just 2
-- (+) <$> Just 3 <*> Just 2
-- pure (+) <*> Just 3 <*> Just 2
{-
Just (+) <*> Just 1 <*> Just 2
= (fmap (+) Just 1) <*> Just 2
= Just (1+) <*> Just 2
= fmap (1+) (Just 2)= Just 3
-}
pure (+) <*> Just 3 <*> Nothing
> Nothing
````

可以看出`pure`是指明构造器，`(<*>)`核心算法解构逻辑。

````haskell
(pure (+) <*> Just 3) <*> Just 2
= (Just (+) <*> Just 3) <*> Just 2 -- pure of Maybe is Just 
````

从定义上看，

`pure f <*> x` 等价于 `fmap f x`

**lift函数**

Module Control.Applicative

````haskell
liftA2 (+) [1] [2]
> [3]

liftA2 (+) (Just 1)  (Just 2)
> Just 3
````

甚至更进一步，可以定义一个中缀表达式:

中缀表达式不能包含字符或数字，所以通常是这些奇奇怪怪的特殊符号

````haskell
(++^) :: (Applicative f, Num a) => f a -> f a -> f a
(++^) = liftA2 (+)

infixl 6 ++^

Just 1 ++^ Just 2
> Just 3

[1] ++^ [2]
> [3]
````

计算第一个参数但忽略结果，返回第二个：(*>)

相反地返回第一个参数 的是 (<*)

````haskell
(*>) = liftA2 (const id)  -- const 1 2 =》 1

Just 1 *> Just 2
> Just 2

(<*) = liftA2 const
Just 1 <* Just 2
> Just 1
````

同样是(<$)  =  fmap . const

````haskell
2 <$ (Just 3)
> Just 2
````

#### 6.2 Alternative Functor

Module Control.Applicative

````haskell
infixl 3 <|>
class Applicative f => Alternative f where
	empty :: f a
    (<|>) :: f a -> f a -> f a
````

<|> ：其他的选择

````haskell
> Nothing <|> Nothing <|> Just 1 <|> Just 2
> Just 1
````

#### 7 List is homogenous: [a]

注意Haskell的列表元素要求是同构的，比如要求是函数，要求签名一致